## 자바스크립트함수
### 함수정의  
  #### 함수 선언문 : function 키워드로 시작
```javascript
  function myFunc(param){
      //실행영역
  }
```  
  #### 함수 표현식 : 함수 리터럴을 사용해서 변수에 함수를 할당
```javascript
  const myFunc = function(param){
      //실행영역
  }
```
  #### 화살표 함수  
  * 파라미터가 1개이면 () 생략가능. 0개이거나 2개이상이면 반드시 표기
  * { } 생략하면 return문도 생략가능.
  * 콜백함수와 익명함수에도 사용
```javascript
    const myfunc = function(param) { return 결과 }
    const myFunc = (param) => { return 결과  }
    const myFunc = param => 결과
```


### 함수 파라미터
  * 파라미터 수와 함수 호출 시 넘겨주는 인자 개수가 일치하지 않아도 된다. 
  
  * 기본 파라미터 : 없는 파라미터는 'Undefined'로 전달되었으나 ES6에서 파라미터에 기본값 지정이 가능함.
  ```javascript
  const myFunc = function(a=0, b=0){
      //실행영역
  }
  myFunc(1)  // b=0으로 초기화됨
  ```
  
  * 나머지 파라미터(=가변파라미터) : ...(점3개)으로 표시. 맨 마지막 위치에만 사용가능함.
  ```javascript
  const myFunc = function(a,b,...args){   // a,b는 필수파라미터. 나머지는 0개에서 n개까지 배열로 받음
      //실행영역
  }
  ```
* arguments : 함수 실행 시 함수로 전달된 인자들의 정보를 담고 있는 객체. 자동생성


### 커링 함수(=partial application)  
  * 한번에 인수를 하나만 받는 함수  
  * 함수를 단순하고 읽기 쉬운 여러 개의 나누어진 부분으로 만드는 기법
  * n개의 파라미터를 n차 depth를 가진 함수로 분리
  * 중간 단계까지만 실행한 결과를 변수로 받아 다음 파라미터를 다양하게 확장이 가능하다. 파라미터가 많을 경우 코드 재활용성을 극단적으로 높일 수 있다.
```javascript
    function orderSet(burger, beverage){
        console.log('세트 ' + burger +"," + beverage);
    }
```
```javascript
    function orderSet(burger){
        return function(beverage) {
            console.log('세트 ' + burger +"," + beverage);
        }
    }
    function orderSet(burger){
        return function(beverage) {
            console.log('세트 ' + burger +"," + beverage);
        }
    }

    let order = orderSet('치즈버그');
    order('콜라');
    order('커피');
    orderSet('치즈버그')('우유');
```
```javascript
    const orderSet = burger => beverage => {
        console.log('세트 ' + burger +"," + beverage);
    }
```

### 펼침(=확산) 연산자(spread operator)
  * 배열과 객체를 복사하거나 합할때 사용 가능
  ```javascript
    var arr = [1,2,3]
    var arr2 = [...arr,4,5]                // [1, 2, 3, 4, 5]  

    var obj1 = {name:'aa', age:20}
    var obj2 = {name:'bb', addr:'dg'}
    var obj3 = {...obj1, ...obj2}          // {name: 'bb', age: 20, addr: 'dg'}  키가 중복되면 덮어쓴다
```
  * 함수 호출시  인자로 사용
```javascript
   let calc = function(x,y,z) { console.log(x,y,z) }
   let calc2 = function(x, ...params) { console.log(x,params) }
   calc(...arr);
   calc2(...arr);
```



### 프로토타입기반언어
1. 프로토타입
  * [참고사이트](https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67) 
  * 객체는 함수를 통해서 만들어진다.
  * String, Array 등 모두 함수로 정의되어 있다. "typeof String" 의 결과는 "f"
  * 함수를 정의하면 함수만 생성되는 것이 아니라 Prototype Object도 같이 생성 [함수정의](img/protorype01.png)
  * Prototype Object는 일반적인 객체이므로 속성을 마음대로 추가/삭제 할 수 있습니다. kim과 park은 Person 함수를 통해 생성되었으니 Person.prototype을 참조할 수 있게 
  * [함수정의실습](img/protorype02.png) 
  * 프로토타입 = prototype Link + prototype Object

2. 객체생성
  * 객체리터럴(Object 생성자의 축약형)  
    var emp = {}    
  * Object 생성자함수  
    var emp = new Object()   
  * 사용자 정의 생성자 함수  
    function Emp(){}  
    var emp = new Emp();


3. 클래스
  * 객체 리터럴보다는 우수
  * ES6에서 클래스 문법이 추가됨. 클래스 기반으로 바뀐 것은 아님.
  * 상속이 가능


| 프로토타입                        | 클래스           |
| -------------------------------- | :------------------ |
|                    | Ctrl + `            |

```javascript
class Estimate {
    constructor(param){
        this.unit = param;
    }
    getEstimate(unittype, width, height){
        let priceinfo = this.unit.find(item=>item.type == unittype);
        return priceinfo.price*width*height;
    }
    addUnit(unit){
        unit.push(unit);
    }
}
let unitinfo = [
    { type: 'wood', price:100 },
    { type: 'iron', price:300 },
    { type: 'plastic', price:200 }
    ];
const estimator = new Estimate(unitinfo);
let result = estimator.getEstimate('wood',20,20);
console.log(result);
```