---
title: "class"
date: 2021-11-08
categories: javascript  
---
### 프로토타입기반언어
* [참고사이트](https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67){:target="_blank"}  
* 객체는 함수를 통해서 만들어진다.
* String, Array 등 모두 함수로 정의되어 있다. "typeof String" 의 결과는 "f"
* 함수를 정의하면 함수만 생성되는 것이 아니라 Prototype Object도 같이 생성 [함수정의](/img/protorype01.png)
* Prototype Object는 일반적인 객체이므로 속성을 마음대로 추가/삭제 할 수 있습니다.
* [함수정의실습](/img/protorype02.png) 
* 프로토타입 = prototype Link + prototype Object
  * `프로토타입 링크` : 인스턴스를 생성할 때 프로토타입에 대한 연결을 생성


## 객체생성
* 객체리터럴(Object 생성자의 축약형)  
    var emp = {}    

* Object 생성자함수  
    var emp = new Object()   

* 사용자 정의 생성자 함수  
    function Emp(){}  
    var emp = new Emp();


### 클래스
* 객체 리터럴보다는 우수
* ES6에서 클래스 문법이 추가됨. 클래스 기반으로 바뀐 것은 아님.
* 상속이 가능
* class 키워드 사용
```javascript
class Estimate {
    constructor(param){
        this.unit = param;
    }
    getEstimate(unittype, width, height){
        let priceinfo = this.unit.find(item=>item.type == unittype);
        return priceinfo.price*width*height;
    }
    addUnit(unit){
        unit.push(unit);
    }
}
let unitinfo = [
    { type: 'wood', price:100 },
    { type: 'iron', price:300 },
    { type: 'plastic', price:200 }
    ];
const estimator = new Estimate(unitinfo);
let result = estimator.getEstimate('wood',20,20);
console.log(result);
```

### 클래스 상속


### this 컨텍스트 범위와 바인딩
* this는 객체 자신을 가리키는 지시자
* this 지시자는 객체 메서드를 호출할 때 메서드를 호출한 객체에 대한 정보를 암시적으로 this 파라미터로 함께 전달. 파라미터와 같은 특징을 가짐
* 함수 안에서만 유효하며 메서드 안에서 별도의 내부 함수를 추가선언해서 사용하거나 객체 외부 함수를 호출하는 경우 다시 호출된 함수 안에서는 this  지시자로 객체에 접근할 수 없다. 접근하려면 this를 명시적으로 파라미터로 넘겨야 한다.(bind() 사용)
* 실습파일 : 03_06_01_this.html, 03_06_01_this2.html 


### 클로저  
* 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우, 함수의 실행 컨텍스트가 종료된 후에도 변수가 사라지지 않는 현상 
* 내부함수를 외부로 전달하는 방법에는 함수를 return하거나 콜백으로 전달  
* 클로저 함수를 호출한 함수가 종료되었더라도 클로저 함수가 사용이 된다면 종료된 함수의 변수를 기억
* 클로저는 그 본질이 메모리를 계속 차지하는 개념이므로 더는 사용하지 않게 된 클로저에 대해서는 메모리를 차지하지 않도록 관리
* 실습파일 : 03_07_01_closure.html
* [참고: 코어자바스크립트|위키북스|p145]  

### 객체의 단축 속성명
```javascript
let name = '라이언'
let age = 5;
let getName = function(){ return this.name}
let friends = {name, age, getName}   //{name:name, age:age, getName:getName}
console.log(friends.getName()) 
```
### 단축 메서드명
```javascript
let calc = { add(a,b){return a+b},
             multiply(a,b){return a*b},
             subtract(a,b){return a-b},
}
console.log(calc.add(1,2))
```
### 계산된 속성명
* []로 감싸먄 속성명을 동적으로 지정
```javascript
let idx = 0;
let obj = { ["name"+ ++idx]:idx , ["name"+ ++idx]:idx , ["name"+ ++idx]:idx }
console.log(obj)
```

## 맵

## 셋

## 모듈